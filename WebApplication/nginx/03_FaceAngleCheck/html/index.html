<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FaceLandmarker: BBox + Landmarks + Pitch/Yaw/Roll</title>
  <link rel="stylesheet" href="assets/style.css">
</head>
<body>
  <div id="root">
    <div class="w-full min-h-screen bg-slate-50 text-slate-900">
      <div class="max-w-6xl mx-auto p-6">
        <header class="mb-4">
          <h1 class="text-3xl font-bold tracking-tight">MediaPipe FaceLandmarker Demo</h1>
          <p class="text-sm text-slate-600">Click Start to open the camera and show face bounding box, landmarks, and Pitch/Yaw/Roll (approximate).</p>
        </header>
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <section class="bg-white rounded-2xl shadow p-4">
            <div id="wrap" class="relative inline-block">
              <div class="absolute inset-0 -scale-x-100 pointer-events-none" id="mirrorProxy" hidden></div>
              <video id="video" autoplay playsinline muted class="rounded-xl bg-black block"></video>
              <canvas id="overlay" class="absolute inset-0 z-10 pointer-events-none block"></canvas>
            </div>
            <div class="mt-3 flex flex-wrap items-center gap-2">
              <button class="px-4 py-2 rounded-xl bg-emerald-600 text-white hover:bg-emerald-700 shadow" id="startBtn">Start</button>
              <div id="info">-</div>
            </div>
          </section>
          <section class="bg-white rounded-2xl shadow p-4">            
            <h3 class="text-sm font-semibold mb-1">Pose</h3>
            <div class="grid grid-cols-3 gap-3">
              <div class="p-3 rounded-xl border border-slate-200">
                <div class="text-xs text-slate-500">Roll</div>
                <div class="text-2xl font-semibold" id="roll">—</div>
              </div>
              <div class="p-3 rounded-xl border border-slate-200">
                <div class="text-xs text-slate-500">Pitch</div>
                <div class="text-2xl font-semibold" id="pitch">—</div>
              </div>
              <div class="p-3 rounded-xl border border-slate-200">
                <div class="text-xs text-slate-500">Yaw</div>
                <div class="text-2xl font-semibold" id="yaw">—</div>
              </div>
            </div>
            <div class="mt-4">
              <h3 class="text-sm font-semibold mb-1">Bounding Box</h3>
              <div class="grid grid-cols-2 gap-3">
                <div class="p-3 rounded-xl border border-slate-200">
                  <div class="text-xs text-slate-500">X</div>
                  <div class="text-2xl font-semibold" id="x">—</div>
                </div>
                <div class="p-3 rounded-xl border border-slate-200">
                  <div class="text-xs text-slate-500">Y</div>
                  <div class="text-2xl font-semibold" id="y">—</div>
                </div>
                <div class="p-3 rounded-xl border border-slate-200">
                  <div class="text-xs text-slate-500">W</div>
                  <div class="text-2xl font-semibold" id="w">—</div>
                </div>
                <div class="p-3 rounded-xl border border-slate-200">
                  <div class="text-xs text-slate-500">H</div>
                  <div class="text-2xl font-semibold" id="h">—</div>
                </div>
              </div>
            </div>
          </section>
        </div>

        <script type="module">
          import {
            FaceLandmarker,
            FilesetResolver,
            DrawingUtils
          } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.21";

          const video = document.getElementById("video");
          const canvas = document.getElementById("overlay");
          const ctx = canvas.getContext("2d");
          const info = document.getElementById("info");
          const startBtn = document.getElementById("startBtn");
          const rollElement = document.getElementById("roll");
          const pitchElement = document.getElementById("pitch");
          const yawElement = document.getElementById("yaw");
          const xElement = document.getElementById("x");
          const yElement = document.getElementById("y");
          const wElement = document.getElementById("w");
          const hElement = document.getElementById("h");
          const wrap   = document.getElementById("wrap");
          let dpr = window.devicePixelRatio || 1;
          let vw = 0, vh = 0;

          let landmarker = null;
          let running = false;

          // Angle estimation (simple approximation)
          const rad2deg = r => r * 180 / Math.PI;

          function eulerFromLandmarks(lm, vw, vh) {
            // Representative landmark indices (MediaPipe FaceMesh convention, adjust if needed)
            const IDX = {
              L_EYE_OUT: 33,
              R_EYE_OUT: 263,
              NOSE_TIP: 1,
              MOUTH: 13,
              CHIN: 152,
              TOP: 10
            };
            const p = i => ({ x: lm[i].x * vw, y: lm[i].y * vh });

            const le = p(IDX.L_EYE_OUT);
            const re = p(IDX.R_EYE_OUT);
            const nose = p(IDX.NOSE_TIP);
            const mouth = p(IDX.MOUTH);

            const eye_dx = re.x - le.x;
            const eye_dy = re.y - le.y;
            const eye_dist = Math.hypot(eye_dx, eye_dy) + 1e-6;

            // Roll: angle of line connecting outer eye corners
            const roll = -rad2deg(Math.atan2(eye_dy, eye_dx));

            // Yaw: horizontal offset of nose tip from eye midpoint, normalized by eye distance
            const eye_mid_x = (le.x + re.x) / 2;
            const yaw_norm = (nose.x - eye_mid_x) / eye_dist;
            const yaw = yaw_norm * 40; // empirical scaling

            // Pitch: vertical offset of mouth from eye midpoint, normalized
            const eye_mid_y = (le.y + re.y) / 2;
            const pitch_norm = (mouth.y - eye_mid_y) / eye_dist;
            const pitch = (0.5 - pitch_norm) * 50; // empirical scaling

            // Tight bounding box for the face
            let minx = 1e9, miny = 1e9, maxx = -1e9, maxy = -1e9;
            for (const l of lm) {
              const x = l.x * vw, y = l.y * vh;
              if (x < minx) minx = x;
              if (x > maxx) maxx = x;
              if (y < miny) miny = y;
              if (y > maxy) maxy = y;
            }
            const bbox = { x: Math.round(minx), y: Math.round(miny), w: Math.round(maxx - minx), h: Math.round(maxy - miny) };

            return { roll, yaw, pitch, bbox };
          }

          // Simple exponential moving average to smooth noisy angles
          function makeEMA(alpha = 0.5) {
            let st = null;
            return (v) => {
              if (!st) st = { ...v };
              else {
                st.roll  = alpha * v.roll  + (1 - alpha) * st.roll;
                st.yaw   = alpha * v.yaw   + (1 - alpha) * st.yaw;
                st.pitch = alpha * v.pitch + (1 - alpha) * st.pitch;
                st.bbox  = v.bbox; // bbox is updated directly
              }
              return st;
            };
          }
          const smoothEuler = makeEMA(0.4);

          // Initialization and main loop
          startBtn.onclick = async () => {
            startBtn.disabled = true;

            // Start camera
            const stream = await navigator.mediaDevices.getUserMedia({
              video: { width: { ideal: 640 }, height: { ideal: 480 }, frameRate: { ideal: 30 } },
              audio: false
            });
            video.srcObject = stream;
            await video.play();

            // Match canvas size to video
            canvas.width = video.videoWidth || 640;
            canvas.height = video.videoHeight || 480;

            // Load FaceLandmarker
            const fileset = await FilesetResolver.forVisionTasks(
              "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.21/wasm"
            );
            landmarker = await FaceLandmarker.createFromOptions(fileset, {
              baseOptions: {
                modelAssetPath: "models/face_landmarker.task",
                delegate: "GPU",
              },
              runningMode: "VIDEO",
              numFaces: 1,
              outputFaceBlendshapes: false,
              outputFacialTransformationMatrixes: false
            });

            running = true;
            loop();
          };

          const drawer = new DrawingUtils(ctx);
          let lastTs = 0;

          function loop() {
            if (!running) return;
            const ts = performance.now();

            // Skip frames to reduce load (~15fps)
            if (ts - lastTs < 66) {
              requestAnimationFrame(loop);
              return;
            }
            lastTs = ts;

            const vw = video.videoWidth, vh = video.videoHeight;
            const result = landmarker.detectForVideo(video, ts);

            // Clear overlay canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (result && result.faceLandmarks && result.faceLandmarks.length > 0) {
              const lm = result.faceLandmarks[0];

              // Draw landmark points
              drawer.drawLandmarks(lm, { radius: 1.2 });

              // Estimate angles and bounding box
              const est = smoothEuler(eulerFromLandmarks(lm, vw, vh));

              // Draw bounding box
              ctx.strokeStyle = "rgba(0, 200, 255, 0.9)";
              ctx.lineWidth = 2;
              ctx.strokeRect(est.bbox.x, est.bbox.y, est.bbox.w, est.bbox.h);

              // Update text
              info.textContent = "-";
              rollElement.textContent = `${est.roll.toFixed(1)}°`
              pitchElement.textContent = `${est.pitch.toFixed(1)}°`
              yawElement.textContent = `${est.yaw.toFixed(1)}°`
              xElement.textContent = `${est.bbox.x}`
              yElement.textContent = `${est.bbox.y}`
              wElement.textContent = `${est.bbox.w}`
              hElement.textContent = `${est.bbox.h}`
            } else {
              info.textContent = "No face detected";
            }

            requestAnimationFrame(loop);
          }
        </script>
      </div>
    </div>
  </div>
</body>
</html>